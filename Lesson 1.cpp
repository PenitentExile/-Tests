#include <iostream>
#include <cmath>

using namespace std;

int main()
{

    //    1) На вход подается целое число. Вывести его в обратном порядке.
    //    INPUT: 329821
    //    OUTPUT: 128923

    int normal = 329821;
    int reverse = 0;
    while (normal != 0)
    {
        reverse = reverse * 10; // умножаем искомое число на 10, чтобы прибавить к нему разряд
        reverse = reverse + normal % 10; // записываем в reverse только остаток от деления исходного числа на 10 (последний разряд)
        normal = normal/10; // делим исходное число на десять, чтобы убрать разряд и гоняем цикл пока в нем не останется разрядов (они все запишутся в качестве остатка от деления в обратное число)

    }
    cout << reverse << endl;


//    2) Посчитать количество бит в числе, которые равны 1.
//    INPUT: 31
//    OUTPUT: 5

    int a = 31;
    int bitcount = 0;

    for(size_t i = 0; i < sizeof (int)*8; ++i)
    {
        if ((a & (1 << i)) == pow (2,i))
      ++bitcount;
    }
    cout << bitcount << endl;

//    3) Занулить каждый второй бит в числе, т.е. 1-й, 3-й, 5-й биты и т.д...
//    INPUT: 31
//    OUTPUT: 21

    
    
//    4) Имеется два вектора A и B: A(x1, y1), B(x2, y2). Требуется найти угол между векторами в градусах.
//    Ввод осуществляется так: x1 y1 x2 y2
//    INPUT: 1 1 0 3
//    OUTPUT: 45

//    5) Решение квадратного уравнения, заданного своими коэффициентами: Ax^2 + Bx + C = 0. Рассмотреть ВСЕ случаи.
//    Ввод коэффициентов: A B C
//    Вывод: значения корней
//    INPUT: 3 -2 -1
//    OUTPUT: -0.3 1

//    Доп:
//    6) Вычислить значение sin(x), используя формулу ряда Тейлора: https://en.wikipedia.org/wiki/Taylor_series
//    Вычисления проводить с точностью, когда модуль очередного члена последовательности будет меньше, чем заданная константа EPS = 1e-5 (std::fabs(currentValue) < EPS).
//    Результат сравнить со станадартной математической функцией std::sin(x) (#include <cmath>)
}
